I will develop a business report to determine which genres generate the most revenue and which types of film ratings are rented the most frequently to support optimizing inventory and marketing opportunities for long-term profitable growth.  

Detailed Table 
Genre - Datatype: Variable Character String (VARCHAR); length 25 characters // Definition: category name used for identifying genres
Title - Datatype: Variable Character String (VARCHAR); length 255 characters // Definition: film title used to identify which movie is associated with a particular rental
Rating - Datatype: Enumerated (MPAA_RATING) // Description: Motion Picture Association of America (MPAA) film rating system identifier
Amount - Datatype: Numeric (NUMERIC); format (5, 2) // Definition: amount paid by a customer for a rental and used for calculating total category revenue

Summary Table
Genre - Datatype: Variable Character String (VARCHAR); length 25 characters // Definition: category name used for identifying genres
Total Revenue - Datatype: Decimal (DECIMAL); format (10,2), default 0.00 // Definition: sum of all payment amounts and provides insight into the total revenue generated by a specific category
Rating - Datatype: Enumerated (MPAA_RATING) // Description: Motion Picture Association of America (MPAA) film rating system identifier
Rating Count - Datatype: Integer (INT); default 0 // Definition: count of all film rating types and provide insight into the most frequently rented ratings

Identify at least two specific tables from the given dataset that will provide the data necessary for the detailed table section and the summary table section of the report.

I would utilize the Category, Film Category, Film, Inventory, Rental, and Payment tables for the Detailed and Summary tables.

Identify at least one field in the detailed table section that will require a custom transformation with a user-defined function and explain why it should be transformed (e.g., you might translate a field with a value of N to No and Y to Yes).

Since it's stored as numeric, I would use a custom transformation with a user-defined function on the amount field from the Payment table to change the format to currency, which would be more visually appealing for stakeholders viewing the report.  

Explain the different business uses of the detailed table section and the summary table section of the report. 

The Detailed Table section of the report has a more in-depth, granular analysis, providing insights into individual transactions that can be used to monitor day-to-day operations and inventory.   The Summary Table section provides a broader overview aligned with strategic planning or forecasting to determine where to invest marketing resources. 

Explain how frequently your report should be refreshed to remain relevant to stakeholders.

At a minimum, refreshing this report quarterly or annually to align with business cycles and planning efforts would be ideal. This frequency ensures that the data is relevant and quantifiable and accounts for seasonality with film distribution, allowing the business to identify trends, monitor performance, and make data-driven decisions regarding customer revenue drivers. 

Code Section

I used these as I was working through my code!!!

DROP FUNCTION IF EXISTS format_currency(amount NUMERIC);
DROP TABLE IF EXISTS detailed_film;
DROP TABLE IF EXISTS summary_film;
DROP TRIGGER IF EXISTS summary_update;

-- Create a user-defined function -- Format the amount as currency

CREATE OR REPLACE FUNCTION format_currency(amount NUMERIC)
RETURNS TEXT 
LANGUAGE plpgsql
AS 
$$
BEGIN
	RETURN ‘$’ || TO_CHAR(amount, ‘FM999,999,999,999.99’);
END;
$$

-- Test function
SELECT format_currency(1234567.89); -- Output should be $1,234,567.89

-- Create a detailed table and a summary table

CREATE TABLE detailed_film(
	genre VARCHAR(25),
	title VARCHAR(255),
	rating MPAA_RATING,
	amount NUMERIC(5,2)
);

CREATE TABLE summary_film(
	genre VARCHAR(25),
	total_revenue DECIMAL(10,2) DEFAULT 0.00,
	rating MPAA_RATING,
	rating_count INT DEFAULT 0  
);

SELECT * FROM detailed_film;
SELECT * FROM summary_film;
 
-- Extract raw data needed for detailed table

INSERT INTO detailed_film (genre, title, rating, amount)
SELECT c.name AS genre, f.title, f.rating, p.amount AS amount
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id 
JOIN film f ON fc.film_id = f.film_id
JOIN inventory i ON fc.film_id = i.film_id 
JOIN rental r ON i.inventory_id = r.inventory_id 
JOIN payment p ON r.rental_id = p.rental_id 
ORDER BY c.name, f.title;

SELECT genre, title, rating, format_currency(amount) AS amount FROM detailed_film ORDER BY genre, title; 
SELECT genre, format_currency(total_revenue) AS total_revenue, rating, rating_count FROM summary_film ORDER BY total_revenue DESC;

-- Create a trigger function

CREATE OR REPLACE FUNCTION summary_film_trigger()
RETURNS TRIGGER
	LANGUAGE plpgsql
AS
$$
BEGIN
  -- Incrementally updates summary table based on new detailed table inserts
	UPDATE summary_film
	SET total_revenue = total_revenue + NEW.amount, rating_count = rating_count + 1
	WHERE genre = NEW.genre AND rating = NEW.rating;

  -- If no rows were updated, insert new row here
	IF NOT FOUND THEN
		INSERT INTO summary_film(genre, total_revenue, rating, rating_count)
		VALUES (NEW.genre, NEW.amount, NEW.rating, 1);
END IF;
RETURN NEW;
END;
$$;

CREATE TRIGGER summary_update
AFTER INSERT ON detailed_film
FOR EACH ROW
EXECUTE PROCEDURE summary_film_trigger();

-- Create a stored procedure

CREATE OR REPLACE PROCEDURE tables_refresh()
LANGUAGE plpgsql
AS
$$
BEGIN

-- Will clear contents from both tables
TRUNCATE TABLE detailed_film, summary_film;

INSERT INTO detailed_film (genre, title, rating, amount)
SELECT c.name AS genre, f.title, f.rating, p.amount AS amount
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id 
JOIN film f ON fc.film_id = f.film_id
JOIN inventory i ON fc.film_id = i.film_id 
JOIN rental r ON i.inventory_id = r.inventory_id 
JOIN payment p ON r.rental_id = p.rental_id 
ORDER BY c.name, f.title;

RETURN;
END;
$$;

CALL tables_refresh()

Identify a relevant job scheduling tool that can be used to automate the stored procedure.

I would use the PostgreSQL extension pg_cron since it allows SQL commands to be scheduled directly in PostgresSQL where the report was created.  This would work well since the stored procedure doesn’t have complex scheduling requirements. 


